import { copyFile, readFile, rm, writeFile } from 'node:fs/promises'
import { resolve } from 'node:path'

import * as vite from 'vite'

import { Context, PackageJson } from 'yakumo'

import { ENTRY, externals, OUT_DIR } from './utils'

export interface PluginManifest {
  name: string
  packageName: string
  version: string
  meta: Record<string, any>
  isDefault: boolean
  dependencies: any
  peerDependencies: any
  peerDependenciesMeta: any
}

export const pluginImport = (manifest: PluginManifest[]) => `// this file is auto generated by yakumo, do not edit it manually.
${manifest.map(plugin => `import ${plugin.isDefault ? '' : '* as '}${plugin.name} from "${plugin.packageName}";`).join('\n')}

export interface PluginManifest {
  name: string
  packageName: string
  // Only used in external plugins from 'createRequire' scope
  path?: string
  meta: Record<string, any>
  version: string
  plugin: any
}

export const plugins: PluginManifest[] = [
  ${manifest.map(plugin => `{
    name: "${plugin.packageName.replace('@satoriapp/plugin-', '')}",
    packageName: "${plugin.packageName}",
    meta: ${JSON.stringify(plugin.meta, null, 2)},
    version: "${plugin.version}",
    plugin: ${plugin.name},
  }`).join(',\n  ')}
]
`

export const bundlePlugins = async (ctx: Context) => {
  const paths = ctx.yakumo.locate(ctx.yakumo.argv._).filter(path => path.startsWith('/plugins'))
  const loaderPackagePath = ctx.yakumo.cwd + '/packages/loader/package.json'
  const manifest: PluginManifest[] = []

  for (const path of paths) {
    const root = ctx.yakumo.cwd + path
    const meta = ctx.yakumo.workspaces[path]
    const entryFile = await readFile(resolve(root, 'src/index.ts'), 'utf-8')
    const isDefaultExport = entryFile.includes('export default') || entryFile.includes('export const defaultExport')
    if (meta && meta['sapp'] && !meta['sapp'].node)
      continue // Skip non-node plugins
    manifest.push({
      name: toCamelCase(meta.name.replace('@satoriapp/plugin-', '')),
      packageName: meta.name,
      version: meta.version,
      meta: meta['sapp'] || {},
      isDefault: isDefaultExport,
      dependencies: meta.dependencies,
      peerDependencies: meta.peerDependencies,
      peerDependenciesMeta: meta.peerDependenciesMeta,
    })

    try {
      const result = await vite.build(vite.defineConfig({
        root,
        build: {
          outDir: resolve(root, OUT_DIR),
          emptyOutDir: true,
          minify: false,
          lib: {
            entry: resolve(root, ENTRY),
            fileName: 'index',
            formats: ['es', 'cjs'],
          },
          rollupOptions: {
            external: externals([
              ...Object.keys(meta?.dependencies || {}),
              ...Object.keys(meta?.peerDependencies || {}),
            ]),
          },
        },
        resolve: {
          alias: {
            // Prevent vite from parsing main/module/exports of package.json incorrectly.
            [meta.name]: resolve(root, ENTRY),
          }
        },
      }))
    } catch (error) {
      ctx.logger('builder').error('build %s failed %c', meta.name, error)
      continue
    }
  }

  await copyFile(loaderPackagePath, loaderPackagePath + '.bak')
  const loaderPackage = JSON.parse(await readFile(loaderPackagePath, 'utf-8')) as PackageJson

  if (!loaderPackage.dependencies) loaderPackage.dependencies = {}

  for (const plugin of manifest) {
    loaderPackage.dependencies[plugin.packageName] = 'workspace:*'
  }

  await writeFile(loaderPackagePath, JSON.stringify(loaderPackage, null, 2))
  await writeFile(resolve(ctx.yakumo.cwd + '/packages/loader/src/plugins.ts'), pluginImport(manifest), 'utf-8')
  ctx.logger('builder').info('bundle plugins [%s] success', manifest.map(plugin => plugin.name).join(', '))
  await rm(loaderPackagePath + '.bak')
}

export function toCamelCase(str: string) {
  return str
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');
}
